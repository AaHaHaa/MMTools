function fun = random_unitary_matrix_generator(use_gpu)
%RANDOM_MATRIX_Create complex block-diagonal-wise random unitary matrices in two ways
%   Use:
%       (1) First generate the function handle,
%
%           fun = random_unitary_matrix_generator;
%           fun = random_unitary_matrix_generator(use_gpu);
%           
%           use_gpu - 0 or 1 (true or false); use gpuArray or not
%           If no "use_gpu", it'll run with CPU.
%
%       (2) Then call the function and generate the output.
%           
%           random_matrix = fun.haar(n,n3);
%           random_matrix = fun.identity_exp(n,n3,eps);
%           random_matrix = fun.identity_rootn(n,n3,rootn);
%           
%           n - an array specifying the dimension (n,n) of the block-diagonal random matrices,
%               where each block is a unitary matrix
%           n3 - the number of random matrices to generate
%           eps - 0~1, a factor determining the randomness and the amount
%                 of deviations from an identity matrix
%           rootn - a numeric number larger than 1; larger rootn means the
%                   output matrix is closer to an identity matrix
%           random_matrix (output) - (n,n,n3) matrix with each nxn a random matrix
%
% -------------------------------------------------------------------------
%
%   Function explanation:
%
%       haar:
%           It generates a random unitary matrix with haar measure from QR
%           decomposition.
%           This can ensure its randomness, which can be checked by looking
%           at the uniformness of eigenvalues on the unit sphere in the
%           complex plane. This can be done by plotting the histogram of 
%           the phase of eigenvalues from thousands of generated random
%           matrices. (absolute value is always one since this is a unitary
%           matrix.)
%
%       identity_exp:
%           It generates a random unitary matrix that can be close to an 
%           identity matrix from "expm(eps*skew-hermitian)" if "eps" is
%           small.
%           
%       identity_rootn:
%           It generates a random unitary matrix that is close to an
%           identity matrix by taking nth-root of random matrix from "haar"
%           above.
%           It's important to know that taking nth-root doesn't imply the
%           randomness after n-times multiplications of these different 
%           nth-root matrices because these "n" matrices are "different".
%           It needs to multiply by more than "n" matrices to regain its
%           randomness. Too small number of multiplications only gives a
%           resulting matrix slightly deviating from an identity matrix.
%
% -------------------------------------------------------------------------
%   Extra explanation:
%
%       Uniformness of eigenvalues:
%           If statistically random, thousands of generated random unitary 
%           matrices should have a uniform distribution of eigenvalues on a
%           unit sphere.
%
%       Propagation of "close-to-identity" random unitary matrix:
%           Even if close to identity, a long propagation, lots of
%           multiplications of different these random matrices, should be
%           close to an entirely random matrix, like the one generated by
%           "haar".
%
% -------------------------------------------------------------------------
%
%   For more information about random matrix with "Haar measure", 
%   please refer to "How to generate random matrices from the classical
%   compact groups" by Francesco Mezzadri.
%
%   link: http://www.ams.org/notices/200705/fea-mezzadri-web.pdf or
%         https://arxiv.org/pdf/math-ph/0609050.pdf

if ~exist('use_gpu','var')
    use_gpu = false;
end

fun.haar = @(n,n3) random_unitary_matrix_with_Haar_measure(n,n3,use_gpu);
fun.identity_exp = @(n,n3,eps) random_unitary_matrix_close_to_identity_exp(n,n3,eps,use_gpu);
fun.identity_rootn = @(n,n3,rootn) random_unitary_matrix_close_to_identity_rootn(n,n3,rootn,use_gpu);

end

%% RANDOM_UNITARY_MATRIX_WITH_HAAR_MEASURE
function q = random_unitary_matrix_with_Haar_measure(n,n3,use_gpu)

[randR,randI,q] = matrix_initialization(n,n3,use_gpu,@randn,@randn,@zeros);
rand_complex = (randR+1i*randI)/sqrt(2);

% Generate "z" as the input of qr decomposition and initialize "q".
% "z" needs to be generated with "randn", not "rand". I tried "rand" and
% eigenvalues aren't uniformly distributed on the unit sphere well enough.
total_previous_n = cumsum(n);
total_previous_n = [0 total_previous_n(1:end-1)];
nidx_in_matrix = arrayfun(@(each_n,previous_n) (1:each_n)+previous_n, n,total_previous_n,'UniformOutput',false);
for ni =1:length(n)
    % Stack nxn matrices in the 3rd dimension.
    for n3idx = 1:n3
        for i = 1:length(n)
            nidx = nidx_in_matrix{ni};
            q(nidx,nidx,n3idx) = random_matrix_from_qr_decomposition(rand_complex(nidx,nidx,n3idx));
        end
    end
end

    % Generate totally random matrix Q from qr decomposition to ensure its randomness.
    function Q = random_matrix_from_qr_decomposition(Z)
        nZ = size(Z,1);
        % Generate Q using CPU since I found out there's a bug in MATLAB
        % that generates all-zero R if the size of Z is larger than 17x17
        % with GPU.
        [Q,R] = qr(gather(Z));
        diagR = diag(R);
        T = diag(diagR./abs(diagR));
        % Regenerate Q if the diagonal part of R unfortunately includes zero,
        % which generates NaN in T.
        nan_yes = isnan(T);
        if any(nan_yes(:))
            if use_gpu
                [randR,randI] = matrix_initialization(nZ,n3,use_gpu,@randn,@randn);
                Z = (randR+1i*randI)/sqrt(2);
                Q = random_matrix_from_qr_decomposition(Z);
            else
                Z = (randn(nZ,nZ,n3)+1i*randn(nZ,nZ,n3))/sqrt(2);
                Q = random_matrix_from_qr_decomposition(Z);
            end
        else
            Q = Q*T;
        end
    end
end

%% RANDOM_UNITARY_MATRIX_CLOSE_TO_IDENTITY_EXP
function rand_matrix = random_unitary_matrix_close_to_identity_exp(n,n3,eps,use_gpu)

% Generate a skew-hermitian matrix & initialize rand_matrix
fun = random_special_matrix_generator(use_gpu);
rand_matrix = matrix_initialization(n,n3,use_gpu,@zeros);
skew_hermitian = fun.skew_hermitian(n,n3);

% Taking matrix exponential to generate a unitary random matrix
% "eps" is used to control the extent of how close to identity it is.
% For small matrices, MATLAB "expm" is faster if n3=1,2.
if n3 < 3
    for i = 1:n3
        rand_matrix(:,:,i) = expm(eps*skew_hermitian(:,:,i));
    end
else
    rand_matrix = pageexpm(eps*skew_hermitian);
end

end

%% RANDOM_UNITARY_MATRIX_CLOSE_TO_IDENTITY_ROOTN
function rand_matrix_rootn = random_unitary_matrix_close_to_identity_rootn(n,n3,rootn,use_gpu)

% Generate a random matrix and initialize rand_matrix_rootn.
rand_matrix = random_unitary_matrix_with_Haar_measure(n,n3,use_gpu);
rand_matrix_rootn = matrix_initialization(n,n3,use_gpu,@zeros);

% Taking nth-root of the random matrix to attain the close-to-identity
% random matrix.
% nth-root is taken by "V * D^(1/n) * V^(-1)", where V is the transformatoin matrix composed of eigenvectors
%                                                    D is the diagonalized matrix
for i = 1:n3
    [v,d] = eig(rand_matrix(:,:,i));
    rand_matrix_rootn(:,:,i) = v*sparse(diag(power(diag(d),1/rootn)))/v; % "sparse" supports only double
end

end

%% MATRIX_INITIALIZATION
function varargout = matrix_initialization(n,n3,use_gpu,varargin)
%MATRIX_INITIALIZATION It initializes (sum(n),sum(n),n3) matrix according 
%to "use_gpu" and the functions defined in varargin. It also works with 
%block-diagonal initialization for "randn".

nfun = length(varargin);

varargout = cell(1,nfun);
single_matrix = cell(1,length(n));
for fidx = 1:nfun
    switch func2str(varargin{fidx})
        case 'randn'
            for nidx = 1:length(n)
                if use_gpu
                    single_matrix{nidx} = feval(varargin{fidx},n(nidx),n(nidx),n3,'gpuArray');
                else
                    single_matrix{nidx} = feval(varargin{fidx},n(nidx),n(nidx),n3);
                end
            end

            if length(n) == 1
                varargout{fidx} = single_matrix{1};
            else
                varargout{fidx} = matrix_initialization(sum(n),1,use_gpu,@zeros);
                for n3idx = 1:n3
                    single_matrix_in_n3idx = cellfun(@(m) m(:,:,n3idx), single_matrix,'UniformOutput',false);
                    varargout{fidx}(:,:,n3idx) = blkdiag(single_matrix_in_n3idx{:});
                end
            end
        case {'zeros','ones'}
            if use_gpu
                varargout{fidx} = feval(varargin{fidx},sum(n),sum(n),n3,'gpuArray');
            else
                varargout{fidx} = feval(varargin{fidx},sum(n),sum(n),n3);
            end
        otherwise
            error('Not supported yet.');
    end
end

end